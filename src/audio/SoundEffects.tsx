import React, { useState, useRef, useEffect, useCallback } from 'react';\n\ninterface SoundEffectsProps {\n  onEffectPlayed?: (effectName: string) => void;\n  volume?: number;\n  autoPlay?: boolean;\n  className?: string;\n}\n\ninterface SoundEffect {\n  id: string;\n  name: string;\n  type: 'beep' | 'swoosh' | 'click' | 'notification' | 'transition' | 'success' | 'error';\n  frequency?: number;\n  duration?: number;\n  waveType?: OscillatorType;\n  description: string;\n}\n\nconst SoundEffects: React.FC<SoundEffectsProps> = ({\n  onEffectPlayed,\n  volume = 0.5,\n  autoPlay = false,\n  className = ''\n}) => {\n  const [audioContext, setAudioContext] = useState<AudioContext | null>(null);\n  const [isEnabled, setIsEnabled] = useState(false);\n  const [lastPlayed, setLastPlayed] = useState<string>('');\n  const [isPlaying, setIsPlaying] = useState<Record<string, boolean>>({});\n  \n  const masterGainRef = useRef<GainNode | null>(null);\n  const activeOscillatorsRef = useRef<Set<OscillatorNode>>(new Set());\n\n  // Sound effects library\n  const soundEffects: SoundEffect[] = [\n    {\n      id: 'slide-transition',\n      name: 'Slide Transition',\n      type: 'transition',\n      frequency: 440,\n      duration: 600,\n      waveType: 'sine',\n      description: 'Smooth slide transition'\n    },\n    {\n      id: 'code-pop',\n      name: 'Code Pop',\n      type: 'notification',\n      frequency: 800,\n      duration: 200,\n      waveType: 'square',\n      description: 'Code block appearance'\n    },\n    {\n      id: 'api-success',\n      name: 'API Success',\n      type: 'success',\n      frequency: 523,\n      duration: 400,\n      waveType: 'sine',\n      description: 'Successful API call'\n    },\n    {\n      id: 'data-flow',\n      name: 'Data Flow',\n      type: 'swoosh',\n      frequency: 300,\n      duration: 800,\n      waveType: 'sawtooth',\n      description: 'Data streaming effect'\n    },\n    {\n      id: 'button-click',\n      name: 'Button Click',\n      type: 'click',\n      frequency: 1000,\n      duration: 100,\n      waveType: 'square',\n      description: 'UI button press'\n    },\n    {\n      id: 'error-alert',\n      name: 'Error Alert',\n      type: 'error',\n      frequency: 200,\n      duration: 300,\n      waveType: 'square',\n      description: 'Error notification'\n    },\n    {\n      id: 'page-whoosh',\n      name: 'Page Whoosh',\n      type: 'swoosh',\n      frequency: 150,\n      duration: 1000,\n      waveType: 'sine',\n      description: 'Page transition swoosh'\n    },\n    {\n      id: 'notification-chime',\n      name: 'Notification Chime',\n      type: 'notification',\n      frequency: 660,\n      duration: 500,\n      waveType: 'sine',\n      description: 'Gentle notification sound'\n    },\n    {\n      id: 'tech-beep',\n      name: 'Tech Beep',\n      type: 'beep',\n      frequency: 1200,\n      duration: 150,\n      waveType: 'square',\n      description: 'Futuristic beep sound'\n    },\n    {\n      id: 'fade-in',\n      name: 'Fade In',\n      type: 'transition',\n      frequency: 350,\n      duration: 1200,\n      waveType: 'triangle',\n      description: 'Gentle fade in effect'\n    }\n  ];\n\n  // Initialize Web Audio API\n  useEffect(() => {\n    const initAudio = async () => {\n      try {\n        const context = new (window.AudioContext || (window as any).webkitAudioContext)();\n        const masterGain = context.createGain();\n        masterGain.connect(context.destination);\n        masterGain.gain.setValueAtTime(volume, context.currentTime);\n        \n        setAudioContext(context);\n        masterGainRef.current = masterGain;\n        setIsEnabled(true);\n      } catch (error) {\n        console.error('Failed to initialize Web Audio API:', error);\n      }\n    };\n\n    initAudio();\n\n    return () => {\n      // Cleanup\n      activeOscillatorsRef.current.forEach(osc => {\n        try {\n          osc.stop();\n        } catch (e) {\n          // Oscillator may already be stopped\n        }\n      });\n      activeOscillatorsRef.current.clear();\n      \n      if (audioContext && audioContext.state !== 'closed') {\n        audioContext.close();\n      }\n    };\n  }, []);\n\n  // Update master volume\n  useEffect(() => {\n    if (masterGainRef.current && audioContext) {\n      masterGainRef.current.gain.setValueAtTime(volume, audioContext.currentTime);\n    }\n  }, [volume, audioContext]);\n\n  const playEffect = useCallback(async (effect: SoundEffect) => {\n    if (!audioContext || !masterGainRef.current || !isEnabled) {\n      console.warn('Audio context not available');\n      return;\n    }\n\n    // Resume audio context if suspended (due to browser autoplay policy)\n    if (audioContext.state === 'suspended') {\n      await audioContext.resume();\n    }\n\n    setIsPlaying(prev => ({ ...prev, [effect.id]: true }));\n    \n    try {\n      switch (effect.type) {\n        case 'beep':\n        case 'click':\n        case 'notification':\n          await playSimpleTone(effect);\n          break;\n        case 'swoosh':\n        case 'transition':\n          await playSwooshEffect(effect);\n          break;\n        case 'success':\n          await playSuccessChord(effect);\n          break;\n        case 'error':\n          await playErrorSound(effect);\n          break;\n        default:\n          await playSimpleTone(effect);\n      }\n      \n      setLastPlayed(effect.name);\n      onEffectPlayed?.(effect.name);\n      \n    } catch (error) {\n      console.error('Error playing sound effect:', error);\n    } finally {\n      setIsPlaying(prev => ({ ...prev, [effect.id]: false }));\n    }\n  }, [audioContext, isEnabled, onEffectPlayed]);\n\n  const playSimpleTone = async (effect: SoundEffect): Promise<void> => {\n    return new Promise((resolve) => {\n      if (!audioContext || !masterGainRef.current) {\n        resolve();\n        return;\n      }\n\n      const oscillator = audioContext.createOscillator();\n      const gainNode = audioContext.createGain();\n      \n      oscillator.type = effect.waveType || 'sine';\n      oscillator.frequency.setValueAtTime(effect.frequency || 440, audioContext.currentTime);\n      \n      // Envelope for smooth attack and decay\n      gainNode.gain.setValueAtTime(0, audioContext.currentTime);\n      gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.01);\n      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + (effect.duration || 200) / 1000);\n      \n      oscillator.connect(gainNode);\n      gainNode.connect(masterGainRef.current);\n      \n      activeOscillatorsRef.current.add(oscillator);\n      \n      oscillator.start(audioContext.currentTime);\n      oscillator.stop(audioContext.currentTime + (effect.duration || 200) / 1000);\n      \n      oscillator.onended = () => {\n        activeOscillatorsRef.current.delete(oscillator);\n        resolve();\n      };\n    });\n  };\n\n  const playSwooshEffect = async (effect: SoundEffect): Promise<void> => {\n    return new Promise((resolve) => {\n      if (!audioContext || !masterGainRef.current) {\n        resolve();\n        return;\n      }\n\n      const oscillator = audioContext.createOscillator();\n      const gainNode = audioContext.createGain();\n      const filter = audioContext.createBiquadFilter();\n      \n      oscillator.type = 'sine';\n      filter.type = 'lowpass';\n      \n      const duration = (effect.duration || 800) / 1000;\n      const startFreq = effect.frequency || 150;\n      const endFreq = startFreq * 3;\n      \n      // Frequency sweep\n      oscillator.frequency.setValueAtTime(startFreq, audioContext.currentTime);\n      oscillator.frequency.exponentialRampToValueAtTime(endFreq, audioContext.currentTime + duration * 0.7);\n      oscillator.frequency.exponentialRampToValueAtTime(startFreq * 0.5, audioContext.currentTime + duration);\n      \n      // Filter sweep\n      filter.frequency.setValueAtTime(startFreq * 2, audioContext.currentTime);\n      filter.frequency.exponentialRampToValueAtTime(endFreq * 2, audioContext.currentTime + duration * 0.5);\n      filter.frequency.exponentialRampToValueAtTime(startFreq, audioContext.currentTime + duration);\n      \n      // Volume envelope\n      gainNode.gain.setValueAtTime(0, audioContext.currentTime);\n      gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + duration * 0.1);\n      gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + duration * 0.9);\n      gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);\n      \n      oscillator.connect(filter);\n      filter.connect(gainNode);\n      gainNode.connect(masterGainRef.current);\n      \n      activeOscillatorsRef.current.add(oscillator);\n      \n      oscillator.start(audioContext.currentTime);\n      oscillator.stop(audioContext.currentTime + duration);\n      \n      oscillator.onended = () => {\n        activeOscillatorsRef.current.delete(oscillator);\n        resolve();\n      };\n    });\n  };\n\n  const playSuccessChord = async (effect: SoundEffect): Promise<void> => {\n    return new Promise((resolve) => {\n      if (!audioContext || !masterGainRef.current) {\n        resolve();\n        return;\n      }\n\n      const baseFreq = effect.frequency || 523; // C5\n      const frequencies = [baseFreq, baseFreq * 1.25, baseFreq * 1.5]; // Major chord\n      const duration = (effect.duration || 400) / 1000;\n      \n      let completedOscillators = 0;\n      \n      frequencies.forEach((freq, index) => {\n        const oscillator = audioContext.createOscillator();\n        const gainNode = audioContext.createGain();\n        \n        oscillator.type = 'sine';\n        oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);\n        \n        const delay = index * 0.05; // Slight stagger\n        const vol = 0.15 / (index + 1); // Decreasing volume for each note\n        \n        gainNode.gain.setValueAtTime(0, audioContext.currentTime + delay);\n        gainNode.gain.linearRampToValueAtTime(vol, audioContext.currentTime + delay + 0.02);\n        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + delay + duration);\n        \n        oscillator.connect(gainNode);\n        gainNode.connect(masterGainRef.current);\n        \n        activeOscillatorsRef.current.add(oscillator);\n        \n        oscillator.start(audioContext.currentTime + delay);\n        oscillator.stop(audioContext.currentTime + delay + duration);\n        \n        oscillator.onended = () => {\n          activeOscillatorsRef.current.delete(oscillator);\n          completedOscillators++;\n          if (completedOscillators === frequencies.length) {\n            resolve();\n          }\n        };\n      });\n    });\n  };\n\n  const playErrorSound = async (effect: SoundEffect): Promise<void> => {\n    return new Promise((resolve) => {\n      if (!audioContext || !masterGainRef.current) {\n        resolve();\n        return;\n      }\n\n      const oscillator = audioContext.createOscillator();\n      const gainNode = audioContext.createGain();\n      \n      oscillator.type = 'square';\n      const duration = (effect.duration || 300) / 1000;\n      const baseFreq = effect.frequency || 200;\n      \n      // Descending frequency for error sound\n      oscillator.frequency.setValueAtTime(baseFreq * 2, audioContext.currentTime);\n      oscillator.frequency.exponentialRampToValueAtTime(baseFreq, audioContext.currentTime + duration);\n      \n      // Rapid volume modulation for harsh effect\n      gainNode.gain.setValueAtTime(0, audioContext.currentTime);\n      gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.01);\n      \n      // Create tremolo effect\n      const lfo = audioContext.createOscillator();\n      const lfoGain = audioContext.createGain();\n      lfo.type = 'sine';\n      lfo.frequency.setValueAtTime(20, audioContext.currentTime); // 20Hz tremolo\n      lfoGain.gain.setValueAtTime(0.1, audioContext.currentTime);\n      \n      lfo.connect(lfoGain);\n      lfoGain.connect(gainNode.gain);\n      \n      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);\n      \n      oscillator.connect(gainNode);\n      gainNode.connect(masterGainRef.current);\n      \n      activeOscillatorsRef.current.add(oscillator);\n      \n      lfo.start(audioContext.currentTime);\n      lfo.stop(audioContext.currentTime + duration);\n      oscillator.start(audioContext.currentTime);\n      oscillator.stop(audioContext.currentTime + duration);\n      \n      oscillator.onended = () => {\n        activeOscillatorsRef.current.delete(oscillator);\n        resolve();\n      };\n    });\n  };\n\n  const playRandomEffect = () => {\n    const randomEffect = soundEffects[Math.floor(Math.random() * soundEffects.length)];\n    playEffect(randomEffect);\n  };\n\n  const stopAllEffects = () => {\n    activeOscillatorsRef.current.forEach(osc => {\n      try {\n        osc.stop();\n      } catch (e) {\n        // Oscillator may already be stopped\n      }\n    });\n    activeOscillatorsRef.current.clear();\n    setIsPlaying({});\n  };\n\n  // Auto-play effect on mount if enabled\n  useEffect(() => {\n    if (autoPlay && isEnabled && soundEffects.length > 0) {\n      playEffect(soundEffects[0]);\n    }\n  }, [autoPlay, isEnabled]);\n\n  return (\n    <div className={`sound-effects ${className}`}>\n      <div className=\"sound-controls\">\n        <div className=\"control-header\">\n          <h3>üîä Sound Effects</h3>\n          <div className=\"global-controls\">\n            <button \n              onClick={() => setIsEnabled(!isEnabled)}\n              className={`toggle-btn ${isEnabled ? 'enabled' : 'disabled'}`}\n              title={isEnabled ? 'Disable sounds' : 'Enable sounds'}\n            >\n              {isEnabled ? 'üîä' : 'üîá'}\n            </button>\n            <button \n              onClick={playRandomEffect}\n              disabled={!isEnabled}\n              className=\"random-btn\"\n              title=\"Play random effect\"\n            >\n              üé≤\n            </button>\n            <button \n              onClick={stopAllEffects}\n              disabled={!isEnabled}\n              className=\"stop-all-btn\"\n              title=\"Stop all sounds\"\n            >\n              ‚èπÔ∏è\n            </button>\n          </div>\n        </div>\n\n        <div className=\"volume-control\">\n          <label>\n            Master Volume: {Math.round(volume * 100)}%\n            <input\n              type=\"range\"\n              min=\"0\"\n              max=\"1\"\n              step=\"0.05\"\n              value={volume}\n              onChange={(e) => {\n                const newVolume = parseFloat(e.target.value);\n                if (masterGainRef.current && audioContext) {\n                  masterGainRef.current.gain.setValueAtTime(newVolume, audioContext.currentTime);\n                }\n              }}\n              disabled={!isEnabled}\n              className=\"volume-slider\"\n            />\n          </label>\n        </div>\n\n        {lastPlayed && (\n          <div className=\"last-played\">\n            Last played: <span className=\"effect-name\">{lastPlayed}</span>\n          </div>\n        )}\n      </div>\n\n      <div className=\"effects-grid\">\n        {soundEffects.map((effect) => (\n          <div key={effect.id} className=\"effect-card\">\n            <div className=\"effect-header\">\n              <h4>{effect.name}</h4>\n              <span className={`effect-type ${effect.type}`}>\n                {effect.type}\n              </span>\n            </div>\n            \n            <div className=\"effect-details\">\n              <p>{effect.description}</p>\n              <div className=\"technical-info\">\n                <span>Freq: {effect.frequency}Hz</span>\n                <span>Duration: {effect.duration}ms</span>\n                <span>Wave: {effect.waveType}</span>\n              </div>\n            </div>\n            \n            <button\n              onClick={() => playEffect(effect)}\n              disabled={!isEnabled || isPlaying[effect.id]}\n              className={`play-effect-btn ${isPlaying[effect.id] ? 'playing' : ''}`}\n              title={`Play ${effect.name}`}\n            >\n              {isPlaying[effect.id] ? 'üîä Playing...' : '‚ñ∂Ô∏è Play'}\n            </button>\n          </div>\n        ))}\n      </div>\n\n      <div className=\"effects-presets\">\n        <h4>Quick Presets:</h4>\n        <div className=\"preset-buttons\">\n          <button \n            onClick={() => playEffect(soundEffects.find(e => e.id === 'slide-transition')!)}\n            disabled={!isEnabled}\n            className=\"preset-btn transition\"\n          >\n            üé¨ Slide Transition\n          </button>\n          <button \n            onClick={() => playEffect(soundEffects.find(e => e.id === 'api-success')!)}\n            disabled={!isEnabled}\n            className=\"preset-btn success\"\n          >\n            ‚úÖ API Success\n          </button>\n          <button \n            onClick={() => playEffect(soundEffects.find(e => e.id === 'error-alert')!)}\n            disabled={!isEnabled}\n            className=\"preset-btn error\"\n          >\n            ‚ùå Error Alert\n          </button>\n          <button \n            onClick={() => playEffect(soundEffects.find(e => e.id === 'data-flow')!)}\n            disabled={!isEnabled}\n            className=\"preset-btn flow\"\n          >\n            üìä Data Flow\n          </button>\n        </div>\n      </div>\n\n      <style jsx>{`\n        .sound-effects {\n          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n          border-radius: 12px;\n          padding: 20px;\n          margin: 16px 0;\n          color: white;\n          box-shadow: 0 8px 32px rgba(0,0,0,0.1);\n        }\n\n        .control-header {\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n          margin-bottom: 16px;\n        }\n\n        .control-header h3 {\n          margin: 0;\n          color: #4facfe;\n        }\n\n        .global-controls {\n          display: flex;\n          gap: 8px;\n        }\n\n        .global-controls button {\n          background: rgba(255,255,255,0.2);\n          border: none;\n          border-radius: 6px;\n          padding: 8px 12px;\n          color: white;\n          cursor: pointer;\n          transition: all 0.3s ease;\n          backdrop-filter: blur(10px);\n        }\n\n        .global-controls button:hover:not(:disabled) {\n          background: rgba(255,255,255,0.3);\n          transform: translateY(-2px);\n        }\n\n        .global-controls button:disabled {\n          opacity: 0.5;\n          cursor: not-allowed;\n          transform: none;\n        }\n\n        .toggle-btn.enabled {\n          background: rgba(79, 172, 254, 0.3);\n        }\n\n        .toggle-btn.disabled {\n          background: rgba(255, 0, 0, 0.3);\n        }\n\n        .volume-control {\n          margin-bottom: 16px;\n        }\n\n        .volume-control label {\n          display: flex;\n          flex-direction: column;\n          gap: 8px;\n          font-size: 14px;\n        }\n\n        .volume-slider {\n          accent-color: #4facfe;\n          height: 6px;\n        }\n\n        .last-played {\n          background: rgba(0,0,0,0.2);\n          padding: 8px 12px;\n          border-radius: 6px;\n          font-size: 14px;\n          margin-bottom: 20px;\n        }\n\n        .effect-name {\n          color: #4facfe;\n          font-weight: 600;\n        }\n\n        .effects-grid {\n          display: grid;\n          grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));\n          gap: 16px;\n          margin-bottom: 24px;\n        }\n\n        .effect-card {\n          background: rgba(255,255,255,0.1);\n          border: 1px solid rgba(255,255,255,0.2);\n          border-radius: 8px;\n          padding: 16px;\n          transition: all 0.3s ease;\n        }\n\n        .effect-card:hover {\n          background: rgba(255,255,255,0.15);\n          transform: translateY(-2px);\n        }\n\n        .effect-header {\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n          margin-bottom: 12px;\n        }\n\n        .effect-header h4 {\n          margin: 0;\n          color: #4facfe;\n        }\n\n        .effect-type {\n          background: rgba(255,255,255,0.2);\n          padding: 4px 8px;\n          border-radius: 4px;\n          font-size: 12px;\n          text-transform: uppercase;\n        }\n\n        .effect-type.transition { background: rgba(79, 172, 254, 0.3); }\n        .effect-type.success { background: rgba(34, 197, 94, 0.3); }\n        .effect-type.error { background: rgba(239, 68, 68, 0.3); }\n        .effect-type.notification { background: rgba(168, 85, 247, 0.3); }\n        .effect-type.swoosh { background: rgba(245, 158, 11, 0.3); }\n        .effect-type.click { background: rgba(156, 163, 175, 0.3); }\n        .effect-type.beep { background: rgba(6, 182, 212, 0.3); }\n\n        .effect-details p {\n          margin: 0 0 8px 0;\n          font-size: 14px;\n          opacity: 0.9;\n        }\n\n        .technical-info {\n          display: flex;\n          gap: 8px;\n          flex-wrap: wrap;\n          margin-bottom: 12px;\n        }\n\n        .technical-info span {\n          background: rgba(0,0,0,0.2);\n          padding: 2px 6px;\n          border-radius: 3px;\n          font-size: 12px;\n          font-family: 'Courier New', monospace;\n        }\n\n        .play-effect-btn {\n          width: 100%;\n          background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);\n          border: none;\n          border-radius: 6px;\n          padding: 10px;\n          color: white;\n          font-weight: 600;\n          cursor: pointer;\n          transition: all 0.3s ease;\n        }\n\n        .play-effect-btn:hover:not(:disabled) {\n          transform: scale(1.02);\n          box-shadow: 0 4px 16px rgba(79, 172, 254, 0.3);\n        }\n\n        .play-effect-btn:disabled {\n          opacity: 0.5;\n          cursor: not-allowed;\n          transform: none;\n        }\n\n        .play-effect-btn.playing {\n          background: linear-gradient(135deg, #34d399 0%, #10b981 100%);\n          animation: pulse 1s infinite;\n        }\n\n        @keyframes pulse {\n          0%, 100% { opacity: 1; }\n          50% { opacity: 0.7; }\n        }\n\n        .effects-presets h4 {\n          margin: 0 0 12px 0;\n          color: #4facfe;\n        }\n\n        .preset-buttons {\n          display: grid;\n          grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n          gap: 12px;\n        }\n\n        .preset-btn {\n          background: rgba(255,255,255,0.1);\n          border: 1px solid rgba(255,255,255,0.2);\n          border-radius: 8px;\n          padding: 12px 16px;\n          color: white;\n          font-weight: 600;\n          cursor: pointer;\n          transition: all 0.3s ease;\n        }\n\n        .preset-btn:hover:not(:disabled) {\n          background: rgba(255,255,255,0.2);\n          transform: translateY(-2px);\n        }\n\n        .preset-btn:disabled {\n          opacity: 0.5;\n          cursor: not-allowed;\n          transform: none;\n        }\n\n        .preset-btn.transition { border-color: rgba(79, 172, 254, 0.5); }\n        .preset-btn.success { border-color: rgba(34, 197, 94, 0.5); }\n        .preset-btn.error { border-color: rgba(239, 68, 68, 0.5); }\n        .preset-btn.flow { border-color: rgba(245, 158, 11, 0.5); }\n\n        @media (max-width: 768px) {\n          .control-header {\n            flex-direction: column;\n            gap: 12px;\n            align-items: stretch;\n          }\n          \n          .global-controls {\n            justify-content: center;\n          }\n          \n          .effects-grid {\n            grid-template-columns: 1fr;\n          }\n          \n          .preset-buttons {\n            grid-template-columns: 1fr;\n          }\n        }\n      `}</style>\n    </div>\n  );\n};\n\nexport default SoundEffects;\n\n// Export individual effect players for use in other components\nexport const playTransitionSound = async (audioContext?: AudioContext, volume = 0.5) => {\n  if (!audioContext) return;\n  \n  const oscillator = audioContext.createOscillator();\n  const gainNode = audioContext.createGain();\n  \n  oscillator.type = 'sine';\n  oscillator.frequency.setValueAtTime(440, audioContext.currentTime);\n  oscillator.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.3);\n  \n  gainNode.gain.setValueAtTime(0, audioContext.currentTime);\n  gainNode.gain.linearRampToValueAtTime(volume * 0.3, audioContext.currentTime + 0.01);\n  gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.6);\n  \n  oscillator.connect(gainNode);\n  gainNode.connect(audioContext.destination);\n  \n  oscillator.start(audioContext.currentTime);\n  oscillator.stop(audioContext.currentTime + 0.6);\n};\n\nexport const playClickSound = async (audioContext?: AudioContext, volume = 0.5) => {\n  if (!audioContext) return;\n  \n  const oscillator = audioContext.createOscillator();\n  const gainNode = audioContext.createGain();\n  \n  oscillator.type = 'square';\n  oscillator.frequency.setValueAtTime(1000, audioContext.currentTime);\n  \n  gainNode.gain.setValueAtTime(0, audioContext.currentTime);\n  gainNode.gain.linearRampToValueAtTime(volume * 0.3, audioContext.currentTime + 0.005);\n  gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);\n  \n  oscillator.connect(gainNode);\n  gainNode.connect(audioContext.destination);\n  \n  oscillator.start(audioContext.currentTime);\n  oscillator.stop(audioContext.currentTime + 0.1);\n};\n\n// Utility for creating custom sound effects\nexport const createCustomEffect = {\n  simple: (frequency: number, duration: number, waveType: OscillatorType = 'sine') => ({\n    id: `custom-${Date.now()}`,\n    name: `Custom ${waveType} ${frequency}Hz`,\n    type: 'notification' as const,\n    frequency,\n    duration,\n    waveType,\n    description: `Custom ${waveType} wave at ${frequency}Hz for ${duration}ms`\n  }),\n  \n  sweep: (startFreq: number, endFreq: number, duration: number) => ({\n    id: `sweep-${Date.now()}`,\n    name: `Frequency Sweep ${startFreq}-${endFreq}Hz`,\n    type: 'swoosh' as const,\n    frequency: startFreq,\n    duration,\n    waveType: 'sine' as OscillatorType,\n    description: `Frequency sweep from ${startFreq}Hz to ${endFreq}Hz over ${duration}ms`\n  })\n};"